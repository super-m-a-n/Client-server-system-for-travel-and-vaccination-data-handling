ΒΑΣΙΛΑΚΗΣ ΒΑΣΙΛΕΙΟΣ ΑΜ : 1115201800018

ΕΝΤΟΛΗ ΕΚΤΕΛΕΣΗΣ :
=====================================

Για την δημιουργία του εκτελέσιμου :
make travelMonitorClient
make monitorServer
./travelMonitor -m numMonitors -b socketBufferSize -c cyclicBufferSize -s sizeOfBloom -i input_dir -t numThreads
όπου παράμετροι όπως στην εκφώνηση και sizeOfBloom-μέγεθος bloom filter τυπικά 100000

ΠΕΡΙΓΡΑΦΗ ΑΡΧΕΙΩΝ :
======================================

Τα παρακάτω αρχεία είναι ακριβώς ίδια με την δεύτερη εργασία και έχουν ακριβώς την ίδια λειτουργικότητα άρα δεν τα ξαναπεριγράφω:
bloom.h, bloom.c 
list.h, list.c,
hash.h, hash.c 
skip_list.c, skip_list.h,
date.h, date.c,
m_items.h, m_items.c,
tm_items.h, tm_items.c,
Στα input_check_client.h, input_check_client.c, input_check_server.h, input_check_server.c υλοποιούνται συναρτήσεις που κάνουν έλεγχο
για τα command line arguments και για το input του χρήστη στα queries, στον travelMonitorClient και στον monitor server αντίστοιχα.

Όσα αρχεία έχουν πρόθεμα m (monitor), αναφέρονται στα monitorServers.
Όσα αρχεία έχουν πρόθεμα tm (travelMonitor), αναφέρονται στο travelMonitorClient.

Στα tm_helper.c, tm_helper.h, υλοποιούνται όλες οι συναρτήσεις που χρειάστηκαν από την πλευρά του travelMonitorClient, 
για να απαντηθούν τα ερωτήματα της εργασίας.

Στα m_helper.c, m_helper.h, υλοποιούνται όλες οι συναρτήσεις που χρειάστηκαν από την πλευρά του monitorServer, 
για να απαντηθούν τα ερωτήματα της εργασίας.

Στα m_threads.c, m_threads.h, υλοποιούνται όλες οι συναρτήσεις που χρειάστηκαν για τον χειρισμό των threads του monitorServer (λεπτομέρειες παρακάτω).

Στα messages.h, messages.c βρίσκονται συναρτήσεις διαχείρισης των μηνυμάτων, ορίζεται το πρωτόκολλο επικοινωνίας κοκ, ακριβώς όπως στην 2η εργασία.
Στο travelMonitorClient.c είναι η main του travelMonitorClient.  Στο monitorServer.c είναι η main του monitorServer.

ΕΠΕΞΗΓΗΣΕΙΣ ΥΛΟΠΟΙΗΣΗΣ / ΠΑΡΑΔΟΧΕΣ :
=====================================

Sockets : Το κομμάτι των sockets δεν θέλει ιδιαίτερη ανάλυση, ακριβώς ότι κάναμε στα pipes κάνουμε και εδώ μόνο που η 
επικοινωνία γίνεται πάνω από τα socket file descriptors (ένα ανά server) αντί για τα read/write file descriptors που είχαμε στα pipes.
Πάλι όπως και στα pipes, πάντα εξασφαλίζεται (μέσω loop στη write/read από το socket) ότι γράφεται/διαβάζεται όλο το μήνυμα.
'Ετσι εξασφαλίζεται και η σωστή επικοινωνία, όταν το socketBufferSize είναι αρκετά μικρότερο από το μήνυμα.
Να τονίσουμε εδώ ότι το socketBufferSize το θεωρούμε τουλάχιστον sizeof(int) bytes (όπως και στη δεύτερη εργασία).

Κάθε φορά που ο travelMonitorClient, αναμένει να διαβάσει κάτι από πολλά Monitor servers, το κάνει μέσω της select, ώστε αν κάποιος 
Monitor server αργεί, να μην τον περιμένει, αλλά να προχωρήσει στους άλλους πρώτα.

Threads : Το θέμα των threads αντιμετωπίστηκε ως ένα producer consumers πρόβλημα πάνω σε ένα bounded buffer, όπου ο producer είναι το αρχικό
νήμα του monitorServer και βάζει συμβολοσειρές-αρχεία προς διάβασμα στο buffer, ενώ οι consumers είναι όλα τα άλλα νήματα που δημιουργεί
το αρχικό νήμα του monitorServer, που διαβάζουν συμβολοσειρές-αρχεία από το buffer, και ενημερώνουν τις κοινές δομές του monitorServer.
Οι κοινοί πόροι, δηλαδή η δομή του cyclic buffer και οι δομές του monitor, προστατεύονται με χρήση ενός κοινού mutex, και δύο condition variables
not-empty, not-full για αναμονή ΧΩΡΙΣ busy waiting σε περίπτωση που το cyclic buffer έχει αδειάσει (στην περίπτωση του consumer) ή έχει γεμίσει
(στην περίπτωση του producer).  Έτσι ο producer βάζει αρχεία προς διάβασμα στον κοινό cyclic buffer, υπό την προστασία του mutex, και ο consumer 
εξάγει ένα αρχείο από τον κοινό cyclic buffer και το διαβάζει και ενημερώνει τις κοινές δομές του monitor υπό την προστασία του mutex.
Επιπλέον, έχουμε ορίσει και 2 ειδικά είδη συμβολοσειρών DONE και EXIT οι οποίες έχουν την εξής χρησιμότητα :
'Οταν ο producer γράψει επιτυχώς όλα τα αρχεία στο cyclic buffer, γράφει μία μόνο συμβολοσειρά DONE στο cyclic buffer.  Αυτή αφού γράφεται
τελευταία, θα διαβαστεί και τελευταία από κάποιο άλλο δευτερεύον thread, και σηματοδοτεί σε αυτό το thread, ότι αυτό θα στείλει πίσω όλα τα bloom
filters στον client.
Η EXIT, χρησιμοποιείται στο τέλος, όταν το αρχικό νήμα του monitorServer, θέλει να τερματίσει, άρα γράφει την συμβολοσειρά EXIT στον κυκλικό buffer,
τόσες φορές όσες τα νήματα που δημιούργησε, και με το που την διαβάζει ένα νήμα, τερματίζει. Έπειτα κάνει join το αρχικό thread σε όλα τα νήματα.
Κατά την διάρκεια των εντολών/queries, όλα τα άλλα νήματα πλην του αρχικού είναι μπλοκαρισμένα, αφού το κυκλικό buffer είναι άδειο.

Πρωτόκολλο επικοινωνίας : Ακριβώς όπως στην δεύτερη εργασία.
Το μόνο νέο σε σχέση με την δεύτερη εργασία, είναι ένα επιπλέον ειδικό μήνυμα (EXIT) το οποίο στέλνει ο travelMonitorClient 
σε όλους τους monitorServers για να σηματοδοτήσει το τέλος της επικοινωνίας.

Τέλος να τονίσουμε ότι για δική σας διευκόλυνση, ανάμεσα στις εκτελέσεις, να διαγράφετε τα logfile της προηγούμενης εκτέλεσης.
Δίνεται και ένα ενδεικτικό input_dir, αν και λογικά θα χρησιμοποιήσετε δικά σας.

Επίσης, Η είσοδος κάθε συμβολοσειράς για τα queries γίνεται μετά το :  "Waiting for command/task >>  " 

